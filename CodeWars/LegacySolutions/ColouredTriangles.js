// A coloured triangle is created from a row of colours, each of which is red, green or blue. Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If they are different, the missing colour is used in the new row. This is continued until the final row, with only a single colour, is generated.

// The different possibilities are:

// Colour here:        G G        B G        R G        B R
// Becomes colour:      G          R          B          G

//PREP
//P: A single string with capital letters containing R, G, or B only. Will not be blank but could only contain 1 letter. 
//R: a single letter, using the key above to reduce the full string to 1 final letter
//E: 
// R R G B R G B B
//  R B R G B R B
//   G G B R G G
//    G R G B G
//     B B R R
//      B G R
//       R B
//        G
//P: Already planning to create a 2nd function just to decide what the next color is going to have to be, this will compare 2 passed letters and return the correct next letter.
//


function triangle(row) {
    let nextRow = [];
    let result = row.split("")
    for (var j=0; j < row.length-1; j++) {
        nextRow = []
        for (var i=0; i <result.length -1; i++){
        nextRow.push(colorMatch(result[i],result[i+1]))
        }
        result = nextRow.slice(0)
    }
    return result.join("")
}
  
function colorMatch(c1, c2) {
    let colors = {"R": 1, "G":2, "B":3}

    if (colors[c1] + colors[c2] ===6) return "B";
    else if (colors[c1] + colors[c2] === 2) return "R"
    else if (colors[c1] + colors[c2] ===4)  return "G"
    else if (colors[c1] + colors[c2] === 3) return "B"
    else if (colors[c1] + colors[c2] === 5) return "R"
}

console.log(triangle('GB'), 'R');
console.log(triangle('RRR'), 'R');
console.log(triangle('RGBG'), 'B');
console.log(triangle('RBRGBRB'), 'G');
console.log(triangle('RBRGBRBGGRRRBGBBBGG'), 'G');
console.log(triangle('B'), 'B');